


-----------------------------------------------------------------------------------------------------------------------
day1 2025/11/10

1.对于回文串怎么解决：
链表：
	一般解：利用哈希集合，遍历，二次遍历，优化：在中间停止然后再进行遍历；
			利用快慢指针+栈，折半进入然后判断
	最优解：对链表进行快慢指针+原地反转，然后判断
数组 ：
	一般用堆/栈来解决 常见的题型如：处理正则表达式


2.如何判断链表是否有环：
	一般解：
		1.哈希集合然后遍历
	最优解：利用快慢指针，两指针相遇即为环的起始节点

如何找到环的入口：快慢指针下，当相遇时让其中一个指针重新回到head,再次让两个指针遍历，他们相遇的地方就是环的入口


什么是快慢指针：快的走两部，慢的走一步
涉及O（1）空间要求时：可能需要利用指针，或者原地反转，或者利用原本已有的空间






--------------------------------------------------------------
day2 2025/11/11


合并链表/数组：
方法：1.双指针+迭代法  ，2.递归法（递归方程）3.原地反转
递归法:
每一层递归：
取当前节点 l1.val 和 l2.val 的和；
计算当前位的节点值；
把进位传递给下一层递归。


3.原地反转法:
关键代码
// 原地反转单链表（Iterative 迭代法）
public ListNode reverse(ListNode head) {
    ListNode prev = null;       // 前驱节点（初始为 null，表示反转后的尾）
    ListNode curr = head;       // 当前节点
    while (curr != null) {
        ListNode next = curr.next;  // 暂存下一个节点
        curr.next = prev;           // 当前节点指向前一个节点（反转方向）
        prev = curr;                // 前驱节点右移
        curr = next;                // 当前节点右移
    }
    return prev;   // prev 最终指向反转后的新头节点
}








--------------------------------------
day3  2025/11/12

138题：
	在今天我学会了哈希表存储两个节点，然后利用哈希表+暴力解法完成链表的copy  
	最优解法（空间（1））：利用原有的链表的空间结构进行改造运用（三步）：
	1.复制每个节点并插入原节点之后
	原链表：	A → B → C        
	改造：	A → A' → B → B' → C → C'
	2.复制 random 指针
	对于每个原节点 A：   A'.random = A.random == null ? null : A.random.next
	证明：A'.random = C' ，如果A.random =C，那么A.random.next(就是C`)=A`.random;
	3.拆分原链表

25题：
	对应翻转k个这种有规律的，可以采用递归写法，
	一般递归函数可能是题目本身的函数，如果不是再自己建
	链表中递归是常用的，时间（O(nlogn）

24题：
	第一种解法：暴力+迭代
	关键核心，掌握节点之间的交换
            ListNode first =cur.next;
            ListNode second =cur.next.next;
	 //交换
         first.next=second.next;
         second.next =first;
         cur.next =second;
	
	第二种：递归



-------------------------------------------
2025/11/13
链表的优点：
链表不能随机访问，因此不适合快速排序或堆排序，但非常适合“归并排序”。






------------------------------------------------
2025/11/14

今天知道了什么是满二叉树，什么是完全二叉树
满二叉树：每个节点要么必须有两个孩子，要么没有孩子
完全二叉树：从上到下从左到右依次填满，只有最后一层可以不满，但必须靠左


最大堆的数据结构实际上就是利用的完全二叉树，只是在呈现方式上运用的是数组
最小堆：根节点是最小的，然后依次类推，越往下的节点越大
最大堆：根节点最大，然后以此类推，越往下节点越小
堆排序（从小到大排序）：利用最大堆，将堆顶元素（最大元素）和最后一个元素交换，然后以此类推，最后就是从小到大的顺序

java中可以直接用的堆数据结构：java.util.PriorityQueue

PriorityQueue<Integer> pq = new PriorityQueue<>();
默认是最小堆

缓存：就是把新的节点/数据存进去，等下次再次需要的时候，能够在O(1)时间内给出
一般有 FIFO,LRU缓存，栈缓存等等的
力扣146题真的具有实践意义



----------------------------------------------------
2025/11/15

学习了双端队列：
双端队列的特点：头尾都能插入，头尾都能删除
运用场景：滑动窗口最大值
		 队列可以轻松模拟栈，普通队列
		广度优先搜索
		缓存类算法的部分实现
		回文串判断
		多任务调度（比较重要的）
		浏览器的前进后退结构


二叉树前中后序遍历：都是深度优先
前序：根->左->右
中序：左->根->右
后续：左->右->根


       A
     /   \
    B     C
   / \   / \
  D   E F   G


递归模版
前序：
void preorder(TreeNode root) {
    if (root == null) return;
    System.out.print(root.val); // 根
    preorder(root.left);        // 左
    preorder(root.right);       // 右
}

中序：
void inorder(TreeNode root) {
    if (root == null) return;
    inorder(root.left);         // 左
    System.out.print(root.val); // 根
    inorder(root.right);        // 右
}

后序：
void postorder(TreeNode root) {
    if (root == null) return;
    postorder(root.left);       // 左
    postorder(root.right);      // 右
    System.out.print(root.val); // 根
}

---------------------------------------------------
2025/11/16

今天学习了jvm的缓存机制，一般的缓存其实它的缓存中的东西最后没有清理
而jvm通过当缓存满时清理就缓存来维持内存不溢出



---------------------------------------------------
2025/11/17

二叉树的算法大多与递归有关
其中重要的有深度优先便利（利用递归）与广度优先遍历（利用队列，先进先出的原则）


队列：
广度优先模版（bfs）:
public void bfs(TreeNode root) {
    if (root == null) return;

    Queue<TreeNode> q = new LinkedList<>();
    q.offer(root);

    while (!q.isEmpty()) {
        int size = q.size();  // 当前层节点数量

        for (int i = 0; i < size; i++) {
            TreeNode node = q.poll();

            // —— 在这里处理当前节点 node ——
            System.out.println(node.val);

            if (node.left != null) q.offer(node.left);
            if (node.right != null) q.offer(node.right);
        }
    }
}

DFS 全称 Depth First Search——深度优先搜索。
全称是 Breadth First Search（广度优先搜索）。


前中后序遍历与深度优先搜索有关
而广度优先搜索是利用队列，先进先出


广度：二叉树每层节点数，翻转二叉树，对称二叉树

深度：最大长度，二叉树高度，等等

===========================================
2025/11/18

二叉搜索树（BST）：满足三个条件
	左子树所有节点的值 < 当前节点值
	右子树所有节点的值 > 当前节点值
	左右子树本身也是 BST	
	作用：可以高效查找，插入，删除，平均时间复杂度o(logn)
平衡二叉搜索树：
	BST 的排序特性（左 < 中 < 右）+平衡限制(子树的高度差不能超过1)

bst的特性：中序遍历下严格递增



中点公式：
1.mid = (l + r) / 2   基础但不安全（如果 l 和 r 都很大（Java int 上限 = 2,147,483,647），l + r 会溢出，导致错误。）
2.mid = l + (r - l) / 2



================================================
2025/11/19

学了一道算法， bst找第k个小的数
两种解法（本质是中序遍历）：
1.深度优先+递归+中序遍历
2.不递归，用栈来迭代，但本质还是中序遍历



===============================================
2025/11/20

力扣105题，前序遍历和中序遍历产生两个数组，
通过两个数组来还原这个二叉树:
方法：
前序遍历：       根  | 左子树 |右子树
中序遍历： 左子树 |     根    | 右子树

通过前序遍历数组中的第一个节点，是根，通过根找到中序遍历数组中有根的那个下标
，再将前序遍历数组中的左子树和中序遍历数组中的左子树 放到递归函数中（来构造左子树）
将前序遍历数组中的右子树和中序遍历数组中的右子树放到递归函数中（构造右子树）

最终完成构造

